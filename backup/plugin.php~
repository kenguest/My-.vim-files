<?php
class IEDRPlugin extends Registry_Plugin {

	// Instance management {{{

	private static $instance = false;

	public static function get_instance() {
		if (self::$instance === false) {
			self::$instance = new IEDRPlugin();
			self::$instance->initialise_live_instance();
		}
		return self::$instance;
	}

	// }}}

	const NS_IEDR = 'http://blacknight.ie/specs/2007/blackreg-iedr/v1';

	// Constants for nag emails.
	const BATCH_SIZE = 75;
	const SLEEP_TIME = 30;

	// Constants for MSD run.
	const MSD_GRACE_PERIOD = 14;

	public function set_session(Transfer_Session $sess) {
		$this->set_console(new IEDR_Console(
			$this->with_logging($sess),
			$this->get_setting('nic'),
			$this->get_setting('password'),
			$this->get_setting('ieapi_version', '1.2')));
	}

	protected function initialise_live_instance() {
		$sess = new Transfer_HTTP_FormVariable($this->get_setting('endpoint'), 'content');
		$sess->set_local_certificate($this->get_setting('certfile'), false, $this->get_setting('bundle'));
		$this->set_session($sess);
	}

	public static function create_mailer(User $account) {
		$loader = new Email_Template_FileLoader(
			dirname(__FILE__) . '/email-templates');
		$mailer = new Email_LiveMailer(
			$account->presales_address,
			$account->logging_address);
		$company = $account->name;
		$nic = self::get_instance()->get_setting('nic');
		return new IEDR_Mailer($loader, $mailer, compact('company', 'nic'));
	}

	public static function create_administrative_mailer() {
		$loader = new Email_Template_FileLoader(
			dirname(__FILE__) . '/email-templates');
		$instance = self::get_instance();
		$mailer = new Email_LiveMailer(
			$instance->get_setting('mail_admin_from'),
			$instance->get_setting('mail_admin_bcc'));
		return new IEDR_Mailer($loader, $mailer);
	}

	// Support {{{

	private function validate_class_category($class, $category) {
		static $mappings = array(
			'Body Corporate (Ltd,PLC,Company)' => array(
				'Corporate Name',
				'Discretionary Name',
				'Publication Name',
				'Registered Business Name',
				'Registered Trade Mark Name'),
			'Constitutional Body' => array(
				'Discretionary Name',
				'Publication Name',
				'Registered Trade Mark Name',
				'State Agency Name'),
			'Discretionary Applicant' => array(
				'Discretionary Name'),
			'Natural Person' => array(
				'Discretionary Name',
				'Personal Name',
				"Politician's Name",
				'Registered Trade Mark Name'),
			'School/Educational Institution' => array(
				'Discretionary Name',
				'Publication Name',
				'Registered Trade Mark Name',
				'School/Educational Institution Name'),
			'Sole Trader' => array(
				'Discretionary Name',
				'Personal Trading Name',
				'Publication Name',
				'Registered Business Name',
				'Registered Trade Mark Name'),
			'Statutory Body' => array(
				'Discretionary Name',
				'Publication Name',
				'Registered Trade Mark Name',
				'State Agency Name'),
			'Unincorporated Association' => array(
				'Discretionary Name',
				'Publication Name',
				'Registered Business Name',
				'Registered Trade Mark Name',
				'Unincorporated Association Name'));
		if (!array_key_exists($class, $mappings)) {
			throw new Registry_PermanentException("Unknown class: '$class'");
		}
		if (!in_array($category, $mappings[$class])) {
			throw new Registry_PermanentException("Category '$category' unknown for class '$class'");
		}
	}

	private function kludge_address(array $contact) {
		$result = array(
			'name' => $contact['name'],
			'organisation' => empty($contact['organisation']) ? 'NONE' : $contact['organisation'],
			'voice' => $contact['voice'],
			'fax' => $contact['fax'],
			'email' => $contact['email']);

		$address_parts = array($contact['addr1'], $contact['addr2'], $contact['town']);
		$area = $contact['area'];
		if (!empty($area)) {
			if (in_array($contact['country_code'], array('US', 'GB', 'IE'))) {
				$area = self::remap_area_name($contact['country_code'], $area);
			} else {
				$address_parts[] = $area;
				$area = '';
			}
		}
		$address_parts[] = $contact['postcode'];
		$result['address'] = implode("\n", array_filter($address_parts));
		$result['area'] = $area;

		// Ah, politics...
		if (IEDR_Console::in_northern_ireland($contact)) {
			$result['country'] = 'Northern Ireland';
		} else {
			$result['country'] = self::get_country_name($contact['country_code']);
		}

		return $result;
	}

	private function get_holder(array $owner, $class) {
		if ($class == 'Natural Person' || empty($owner['organisation']) && ($class == 'Sole Trader' || $class == 'Discretionary Applicant')) {
			return $owner['name'];
		}
		if (!empty($owner['organisation'])) {
			return $owner['organisation'];
		}
		// The IEDR were complaining about our use of 'UNKNOWN', so this'll have to do.
		return $owner['name'];
	}

	public function clean_domain_int(array $domain, $is_update) {
		if (!$is_update) {
			if (!isset($domain['ext']['class'])) {
				$domain['ext']['class'] = 'Discretionary Applicant';
			}
			if (!isset($domain['ext']['category'])) {
				$domain['ext']['category'] = 'Discretionary Name';
			}
		}
		return $domain;
	}

	// }}}

	// DB access {{{

	public static function get_country_name($country_code) {
		return DAO::get_connection()->query_value("SELECT country FROM iedr_countries WHERE country_code = %s", $country_code);
	}

	public static function mark_as_pending($id, $application_type, $expires=null, $class=null, $category=null) {
		if (is_null($expires)) {
			$expires = strtotime("30 days");
		}
		$uri_fragment = make_url_safe_unique_id();
		DAO::get_connection()->execute("
			INSERT INTO iedr_pending (
				id, uri_fragment, application_type, class, category, updated, expires
			) VALUES (
				%d, %s, %s, %s, %s, NOW(), %s
			)
			", $id, $uri_fragment, $application_type, $class, $category, strftime("%Y-%m-%d", $expires));
		return $uri_fragment;
	}

	/**
	 * Remaps an area name onto one the IEDR will accept.
	 */
	public static function remap_area_name($country_code, $area) {
		return DAO::get_connection()->query_value('
			SELECT  COALESCE(use_instead, area)
			FROM    areas
			WHERE   country_code = %s AND %s IN (abbreviation, area)
			', $country_code, $area);
	}

	public static function get_overdue_transfers() {
		return DAO::get_connection()->query_map("
			SELECT	fqdn, domains.id
			FROM	domains
			JOIN	iedr_pending USING (id)
			WHERE	status = 'pending' AND
					completion_status = 'pending' AND
					application_type = 'transfer' AND
			        registered < CURDATE() - INTERVAL 29 DAY");
	}

	public static function purge(array $ids, $msg) {
		if (count($ids) > 0) {
			$db = DAO::get_connection();
			try {
				$db->begin();
				Domains::delete($ids, $msg, 'failed');
				$db->commit();
			} catch (Exception $ex) {
				$db->rollback();
				throw $ex;
			}
		}
	}

	public static function mark_as_registered(array $domain_ids, $downsync=true) {
		if (count($domain_ids) > 0) {
			$db = DAO::get_connection();
			try {
				$db->begin();
				Domains::set_status($domain_ids, 'registered');
				$db->execute('UPDATE domains SET registered = CURDATE() WHERE id in (%d)', $domain_ids);
				if ($downsync) {
					trigger_event('downsync_nameservers', $domain_ids);
				}
				$db->commit();
			} catch (Exception $ex) {
				$db->rollback();
				throw $ex;
			}
		}
	}

	public static function update_pending($id, $class, $category, $status, $remarks, $documentation_received) {
		return DAO::get_connection()->execute('
			UPDATE iedr_pending
			SET    class = %1$s, category = %2$s, current_status = %3$s, remarks = %4$s, documentation_received = %5$s, updated = NOW(), pending_updates = \'Yes\'
			WHERE  id = %6$d AND (class <> %1$s OR category <> %2$s OR current_status <> %3$s OR remarks <> %4$s OR documentation_received <> %5$s)
			', $class, $category, $status, $remarks, $documentation_received ? 'Yes' : 'No', $id);
	}

	public static function get_pending_registrations() {
		return DAO::get_connection()->query_map("
			SELECT	fqdn, domains.id
			FROM	domains
			JOIN	iedr_pending ON domains.id = iedr_pending.id
			WHERE	status = 'pending' AND application_type = 'registration' AND
			        completion_status = 'pending'");
	}

	public static function get_pending_transfers() {
		return DAO::get_connection()->query_row_map("
			SELECT	fqdn, domains.id, alias AS account_contact
			FROM	domains
			JOIN	iedr_pending ON domains.id = iedr_pending.id
			JOIN	iedr_contacts ON domains.account_id = iedr_contacts.id
			WHERE	status = 'pending' AND application_type = 'transfer' AND
			        completion_status = 'pending'");
	}

	public static function get_pending_transfers_subset(array $fqdns) {
		if (count($fqdns) == 0) {
			return array();
		}
		return DAO::get_connection()->query_row_map("
			SELECT	fqdn, domains.id, alias AS account_contact
			FROM	domains
			JOIN	iedr_pending ON domains.id = iedr_pending.id
			JOIN	iedr_contacts ON domains.account_id = iedr_contacts.id
			WHERE   status = 'pending' AND completion_status = 'pending' AND
			        application_type = 'transfer' AND
			        fqdn IN (%s)
			", $fqdns);
	}

	public static function get_syncing_domains() {
		return DAO::get_connection()->query_row_map("
			SELECT	fqdn, domains.id, alias AS account_contact,
			        application_type
			FROM	domains
			JOIN	iedr_pending ON domains.id = iedr_pending.id
			JOIN	iedr_contacts ON domains.account_id = iedr_contacts.id
			WHERE	domains.status = 'pending' AND completion_status = 'syncing'");
	}

	public static function update_completion_status(array $ids, $completion_status, $msg='') {
		if (count($ids) > 0) {
			$db = DAO::get_connection();
			$db->begin();
			try {
				$db->execute('
					UPDATE iedr_pending SET completion_status = %s WHERE id IN (%d)
					', $completion_status, $ids);
				switch ($completion_status) {
				case 'completed':
					$types = $db->query_multimap('
						SELECT application_type, id FROM iedr_pending WHERE id IN (%d)
						', $ids);
					foreach ($types as $type => $type_ids) {
						if ($type == 'transfer') {
							Domains::set_status($type_ids, 'transferred');
						} elseif ($type == 'registration') {
							Domains::set_status($type_ids, 'registered');
						}
					}
					break;

				case 'failed':
					self::purge($ids, $msg);
					break;
				}
				$db->commit();
			} catch (Exception $ex) {
				$db->rollback();
				throw $ex;
			}
		}
	}

	// }}}

	// Event handling {{{

	protected function get_events() {
		return array(
			'clean_domain',
			'check_registered',
			'register_domain',
			'transfer_domain',
			'upsync_nameservers',
			'downsync_nameservers',
			'contact_updated');
	}

	public function register_domain($msg, $details) {
		if (!$this->can_process_tld($details['fqdn'])) {
			return array(true, $details);
		}

		$ext = $details['ext'];

		// Temporary GIBO hacks {{{
		if ($ext['class'] == 'Body Corporate' || $ext['class'] == 'Corporate Body') {
			$ext['class'] = 'Body Corporate (Ltd,PLC,Company)';
		} elseif ($ext['class'] == 'Unincorporated business') {
			$ext['class'] = 'Unincorporated Association';
		}
		// }}}

		$autocreate = isset($ext['autocreate']) && $ext['autocreate'] == 'true';
		$this->validate_class_category($ext['class'], $ext['category']);
		$contacts = $details['contacts'];
		$owner = $this->get_contact('owner', $contacts['owner']);
		$admin = $this->get_contact('admin', $contacts['admin']);
		$account = $this->get_contact('billing', $contacts['account']);

		// Will throw an exception if it fails.
		$ticket_expires = $this->console->register(
			$details['fqdn'],
			$details['years'],
			$details['nss'],
			array(
				// For .ie domains, the details of the admin contact must
				// correspond to those of the holder, thus both contacts
				// reflect the Blackreg owner contact.
				'admin' => $owner['alias'],
				'tech' => $account['alias']),
			$this->get_holder($owner, $ext['class']),
			$ext['class'],
			$ext['category'],
			$details['remarks'],
			$autocreate);

		// So that docs and faxes can be traced later.
		$fragment = self::mark_as_pending(
			$details['id'], 'registration', $ticket_expires, $ext['class'], $ext['category']);

		if (!$autocreate) {
			$mailer = self::create_mailer(Users::current());
			$mailer->registration($details['fqdn'], $ext['category'], $owner, $admin, $fragment);
		}

		// Urg...
		return array(false, false);
	}

	public function register_domain_int($id, $fqdn, $years, array $nss, array $contacts, array $ext, $ref) {
		// XXX Temporary hack.
	}

	public function transfer_domain($msg, $details) {
		if (!$this->can_process_tld($details['fqdn'])) {
			return array(true, $details);
		}

		// Check to make sure that the domain is registered and isn't locked.
		list($free, $taken) = $this->console->check_domains(array($details['fqdn']));
		if (count($free) > 0) {
			throw new Registry_PermanentException(sprintf("'%s' is not registered.", $details['fqdn']));
		}
		switch ($taken[$details['fqdn']]) {
		case 101:
			throw new Registry_PermanentException(sprintf("'%s' is a pending registration; can't transfer.", $details['fqdn']));
		case 102:
			throw new Registry_PermanentException(sprintf("'%s' is locked; can't transfer.", $details['fqdn']));
		}

		// So that docs and faxes can be traced later.
		$fragment = self::mark_as_pending($details['id'], 'transfer');

		$owner_name = '';
		if (!is_null($details['contacts']['owner'])) {
			$owner = Contacts::get($details['contacts']['owner']);
			$owner_name = $owner['name'];
		}
		$admin = Contacts::get($details['contacts']['admin']);
		$mailer = self::create_mailer(Users::current());
		$mailer->transfer($details['fqdn'], $owner_name, $admin['email'], $fragment);
		$mailer->transfer_intent_announcement($details['fqdn']);

		return array(false, false);
	}

	public function transfer_domain_int($id, $fqdn, $years, array $nss, array $contacts, $authcode, array $ext, $ref) {
		// XXX Temporary hack.
	}

	public function renew_domain($id, $fqdn, $increment, $expiration, $profile_id) {
		// The domain can only be renewed if due for renewal this month or
		// the previous month.
		$fut_ren_boundary = strtotime(gmdate('Y-m-01'));

		if ($expiration >= $fut_ren_boundary) {
			$type = 'futRen';
		} elseif ($expiration >= strtotime("-1 month", $fut_ren_boundary)) {
			$type = 'currRenReg';
		} else {
			$type = 'msd';
		}

		if ($type != 'futRen' && $increment != 1) {
			throw new Registry_PermanentException(
				'This domain currently may only be renewed for one year');
		}

		if ($type != 'msd') {
			try {
				$this->console->renew_domains(array($fqdn), $increment, $expiration, $type);
			} catch (Registry_Exception $rex) {
				switch ($rex->getCode()) {
				case 810: // Domain incorrect state for payment
				case 204: // Domain MSD process pending
					// In both cases, the domain is in MSD, so we have to
					// remove it.
					$this->console->remove_from_msd_with_deposit(array($fqdn));
					// When the status is currRenReg, it automatically renews
					// for a year. However, when the status is futRen, we must
					// renew it ourselves post reactivation.
					if ($type == 'futRen') {
						$this->console->renew_domains(array($fqdn), $increment, $expiration, $type);
					}
					break;
				default:
					// Pass it on.
					throw $rex;
				}
			}
		} else {
			$this->console->remove_from_msd_with_deposit(array($fqdn));
		}
	}

	public function upsync_nameservers($msg, $details) {
		if (!$this->can_process_tld($details['fqdn'])) {
			return array(true, $details);
		}

		$this->console->update_nameservers(
			$details['fqdn'], $details['new_nss'], $details['old_nss']);

		return array(false, null);
	}

	public function create_contact($type, $id, array $contact) {
		if ($type == 'owner') {
			return $this->console->create_contact($this->kludge_address($contact));
		}
		return null;
	}

	public function contact_updated($msg, $details) {
		// TODO: We need to have the plugins all validate that they can
		// accept the update first.
		list($contact, $id) = $details;
		$alias = $this->get_contact_alias($id);
		if (!is_null($alias)) {
			$this->console->update_contact($alias, $this->kludge_address($contact));
		}
		return array(true, $details);
	}

	// }}}

	public function check_domains(array $to_check) {
		// When a domain's taken, list is keyed by domain, with the reason
		// being the value.
		list($free, $taken) = $this->console->check_domains($to_check);
		return array($free, array_keys($taken));
	}

	public function get_nameservers_for($fqdn, $authcode=false) {
		try {
			$d = $this->console->query_domain($fqdn);
		} catch (Registry_Exception $rex) {
			if ($rex->getCode() == 200 || $rex->getCode() == 202) {
				// Domain not found.
				$d = $this->console->query_ticket($fqdn);
			} else {
				throw $rex;
			}
		}
		return $d['nameservers'];
	}

	// Cronjobs {{{

	public static function update_pending_registrations() {
		$pending_domain_ids = self::get_pending_registrations();
		if (count($pending_domain_ids) == 0) {
			return;
		}

		$c = self::get_instance()->get_console();

		// First pass through: collect any one-year registrations.
		$registered = array();
		foreach ($c->list_payment_queue('futRen') as $fqdn) {
			if (isset($pending_domain_ids[$fqdn])) {
				$registered[$fqdn] = $pending_domain_ids[$fqdn];
				unset($pending_domain_ids[$fqdn]);
			}
		}

		// Domains that have no ticket, and may either be multi-year registrations,
		// charity registrations, or actually deleted. We collect those to
		// double-check later.
		$to_double_check = array();
		$to_delete = array();
		$lapsed = array();

		foreach ($pending_domain_ids as $fqdn => $id) {
			try {
				$ticket = $c->query_ticket($fqdn);
			} catch (Registry_Exception $rex) {
				switch ($rex->getCode()) {
				case 701: // Ticket doesn't exist
					$to_double_check[$fqdn] = $id;
					break;
				case 702: // Ticket is managed by another reseller
					$to_delete[$fqdn] = $id;
					break;
				default:
					echo "$fqdn: querying ticket gave: ", $rex->getCode(), "\n";
					break;
				}
				continue;
			}
			Domains::save_nameservers($id, $ticket['nameservers']);
			$remarks = $ticket['hostmaster_remarks'];
			$status = $ticket['hostmaster_status'];
			$documentation_received = false;
			if ($status == 'Accepted') {
				$documentation_received = true;
				if ($ticket['dns_status'] != 'New / Not Checked') {
					$status = $ticket['dns_status'];
				}
			}
			self::update_pending($id, $ticket['class'], $ticket['category'], $status, $remarks, $documentation_received);
		}

		if (count($to_double_check) > 0) {
			// Second pass to avert the consequences of a race condition between
			// checking the first time and checking the ticket.
			foreach ($c->list_payment_queue('futRen') as $fqdn) {
				if (isset($to_double_check[$fqdn])) {
					$registered[$fqdn] = $to_double_check[$fqdn];
					unset($to_double_check[$fqdn]);
				}
			}

			list($unregistered, $taken) = $c->check_domains(array_keys($to_double_check));
			foreach ($unregistered as $fdqn) {
				$lapsed[] = $to_double_check[$fdqn];
			}
			foreach ($taken as $fdqn => $status) {
				$id = $to_double_check[$fdqn];
				switch ($status) {
				case 100: // Registered.
					$registered[$fdqn] = $id;
					unset($to_double_check[$fqdn]);
					break;
				case 201: // With another reseller.
					$to_delete[$fqdn] = $id;
					unset($to_double_check[$fqdn]);
					break;
				default:
					echo "$fqdn ($status): WTF?!\n";
					break;
				}
			}
		} else {
			$unregistered = array();
		}
		if (count($lapsed) > 0) {
			self::purge($lapsed, 'Registration failed; application lapsed/cancelled');
		}
		if (count($to_delete) > 0) {
			self::purge($to_delete, 'Registration failed; with another reseller');
		}
		if (count($to_delete) > 0 || count($unregistered) > 0) {
			echo_list('Failed', array_keys($to_delete) + $unregistered);
		}

		if (count($registered) > 0) {
			// Before we go any further, ensure that charity registrations are
			// simply marked as registered and that only one-year registrations
			// are paid for. Everything else is automatically paid from the
			// deposit account. One year registrations are those where the
			// renewal date is the same as the registration date.
			$one_year_registrations = array();
			foreach ($registered as $fqdn => $id) {
				$d = $c->query_domain($fqdn);
				// In case they've been updated independently on the the
				// ticket.
				Domains::save_nameservers($id, $d['nameservers']);
				if ($d['billing_status'] == 'billable' && $d['created'] == $d['expires']) {
					$one_year_registrations[] = $fqdn;
				}
			}
			try {
				if (count($one_year_registrations) > 0) {
					$c->pay_from_deposit('futRen', $one_year_registrations);
				}
				// If we've funding problems, this code won't be reached.
				self::mark_as_registered($registered);
				echo_list('Completed', array_keys($registered));
			} catch (Registry_BillingException $bex) {
				// We could mark the multiyear registrations as completed, but this is simpler.
				echo "Insufficient funds to pay for registrations. Halting, will try later.\n";
			}
		}
	}

	public static function update_pending_gibo_registrations() {
		$pending_domain_ids = self::get_pending_registrations();
		if (count($pending_domain_ids) == 0) {
			return;
		}

		$c = self::get_instance()->get_console();

		$to_delete = array();
		$registered = array();

		foreach ($pending_domain_ids as $fqdn => $id) {
			try {
				$domain = $c->query_domain($fqdn);
				$status = $domain['status'];
			} catch (Registry_Exception $rex) {
				if ($rex->getCode() == 200) {
					// No such domain.
					$to_delete[$fqdn] = $id;
				} elseif ($rex->getCode() == -1) {
					printf("%s: (%s) %s\n", $fqdn, "Can't query.");
				} else {
					printf("%s: (%s) %s\n", $fqdn, $rex->getMessage());
				}
				continue;
			}

			switch ($status) {
			case 'deleted':
				$to_delete[$fqdn] = $id;
				break;
			case 'active':
				$registered[$fqdn] = $id;
				// In case, for some reason, they've been updated.
				// You never know...
				Domains::save_nameservers($id, $domain['nameservers']);
				break;
			}
		}
		if (count($to_delete) > 0) {
			self::purge($to_delete, 'Registration failed; application rejected');
			echo_list('Failed', array_keys($to_delete));
		}

		if (count($registered) > 0) {
			self::mark_as_registered($registered, false);
			echo_list('Completed', array_keys($registered));
		}
	}

	public static function nag() {
		$to_nag = DAO::get_connection()->query_all("
			SELECT	fqdn, name, email,
			        domains.admin_contact_id, application_type,
			        class, category, registered, ref, uri_fragment,
			        domains.account_id
			FROM	domains
			JOIN	iedr_pending ON domains.id = iedr_pending.id
			JOIN	contacts AS o ON owner_contact_id = o.id
			JOIN    contact_details AS a ON a.id = admin_contact_id
			WHERE	status = 'pending' AND documentation_received = 'No' AND
					registered <= CURDATE() - INTERVAL 2 DAY
			ORDER BY domains.account_id, domains.admin_contact_id, domain");

		$mail_registration_cb = null;
		$mail_transfer_cb = null;
		$current_account = null;
		$current_admin = null;
		$registrations = array();
		$transfers = array();
		foreach ($to_nag as $r) {
			// Are we looking at a fresh admin contact?
			if ($r['admin_contact_id'] != $current_admin) {
				// Do we have a batch to send for the previous admin contact?
				if (!is_null($current_admin)) {
					self::send_nags($registrations, $mail_registration_cb);
					self::send_nags($transfers, $mail_transfer_cb);
					$registrations = array();
					$transfers = array();
				}

				// If the admin contact is on a different account from the
				// previous one, we need to set up the mailer callbacks for
				// that account so they can actually, you know, be emailed
				// with the correct account details.
				if ($r['account_id'] != $current_account) {
					$mailer = self::create_mailer(Users::get($r['account_id']));
					$mail_registration_cb = array($mailer, 'registration_reminder');
					$mail_transfer_cb = array($mailer, 'transfer_reminder');
				}
				$current_account = $r['account_id'];
			}
			$current_admin = $r['admin_contact_id'];
			switch ($r['application_type']) {
			case 'registration':
				$registrations[] = $r;
				break;
			case 'transfer':
				$transfers[] = $r;
				break;
			}
		}
		if (!is_null($current_admin)) {
			self::send_nags($registrations, $mail_registration_cb);
			self::send_nags($transfers, $mail_transfer_cb);
		}
	}

	private static function send_nags(array $domains, $mailer_cb) {
		static $n_sent = 0;
		if (count($domains) > 0) {
			call_user_func($mailer_cb, $domains);
			// Sleep periodically to allow the mailserver to catch its breath.
			$n_sent++;
			if ($n_sent == self::BATCH_SIZE) {
				sleep(self::SLEEP_TIME);
				$n_sent = 0;
			}
		}
	}

	public static function purge_outgoing_transfers() {
		$c = self::get_instance()->get_console();
		$fqdns = array();
		foreach ($c->list_domains('transfer', array('subtype' => 'outbound', 'month' => gmdate('Y-m', strtotime('yesterday')))) as $fqdn) {
			$fqdns[] = $fqdn;
		}
		Domains::delete(Domains::get_domain_id_map($fqdns), 'Transferred away');
	}

	public static function update_expiring_domains() {
		$c = self::get_instance()->get_console();

		// Because we want to catch charity/nonbillable domains on their last day.
		$domains = Domains::get_expired_domains('ie', -1);
		$autorenewed = array();
		$expired = array();
		$transferred = array();
		foreach ($domains as $fqdn => $r) {
			try {
				$details = $c->query_domain($fqdn);
				if ($details['billing_status'] == 'notbillable' || $details['billing_status'] == 'charity') {
					// Charity or other non-billable domains.
					$autorenewed[] = $r['id'];
				}
			} catch (Registry_Exception $rex) {
				switch ($rex->getCode()) {
				case 200:
					$expired[] = $r['id'];
					break;
				case 201: // With another reseller.
				case 102: // Locked; with another reseller.
					$transferred[] = $r['id'];
					break;
				default:
					AFK::dump($rex);
					// Wait to avoid putting load on the IEDR's server.
					sleep(10);
				}
			}
		}

		Domains::increment_years($autorenewed, 1);
		Domains::delete($expired, 'Lapsed');
		Domains::delete($transferred, 'Transferred away');
	}

	private static function do_msd_run_int($account_id, $n, $body) {
		$msg  = "The following .ie domains are due to be placed in MSD. This list does not\n";
		$msg .= "include already-MSD'd domains. Note that domains are only placed in MSD on\n";
		$msg .= "Fridays.\n\n";

		$msg .= "Total number to MSD: " . $n . "\n";
		$msg .= "MSD grace period in days: " . self::MSD_GRACE_PERIOD . "\n\n";

		$msg .= "Domain                                                 Expires     Overdue\n";
		$msg .= "-----------------------------------------------------  ----------  -------\n";

		$msg .= $body;

		$account = Users::get($account_id);
		$to = $account->notifications_address;
		if ($to != $account->accounts_address) {
			$to .= ', ' . $account->accounts_address;
		}
		send_administrative_email($to, 'MSD-able .ie domains', $msg);
	}

	public static function do_msd_run() {
		// What do we see as expired?
		$domains_to_msd = Domains::get_expired_domains('ie', max(self::MSD_GRACE_PERIOD - 1, 0));

		// Clear out any that have already been MSD'd, and mark any that have been
		// manually MSD'd. This allows renewals to be processed.
		$c = self::get_instance()->get_console();
		$domains_in_msd = array();
		foreach ($c->list_msd_domains() as $d => $_info) {
			unset($domains_to_msd[$d]);
			$domains_in_msd[] = $d;
		}

		// Mark domains that have been manually MSD'd as expiring.
		if (count($domains_in_msd) > 0) {
			DAO::get_connection()->execute("
				UPDATE  domains
				SET     status = 'expiring'
				WHERE   status = 'registered' AND fqdn IN (%s)
				", $domains_in_msd);
		}

		if (count($domains_to_msd) == 0) {
			return;
		}

		// On Fridays and only on Fridays, we place any domains beyond the
		// grace period in MSD.
		$is_friday = gmdate('N') == 5;
		$msd_list = array();

		$current_account = null;
		$last_expires = null;
		$n = 0;
		$body = '';
		foreach ($domains_to_msd as $fqdn => $r) {
			// Starting a new batch?
			if ($current_account != $r['account_id']) {
				// Email previous batch.
				if (!is_null($current_account)) {
					self::do_msd_run_int($current_account, $n, $body);
				}
				$body = '';
				$n = 0;
				$last_expires = null;
			}
			$current_account = $r['account_id'];

			if ($r['expires'] != $last_expires) {
				if ($r['overdue'] < self::MSD_GRACE_PERIOD) {
					$body .= "\n-- CUTOFF -------------------------------------------  ----------  -------\n";
				}
				$body .= "\n";
				$last_expires = $r['expires'];
			}
			$body .= sprintf("%-53s  %-10s  %7d\n", $fqdn, $r['expires'], $r['overdue']);
			$n++;
			if ($is_friday && $r['overdue'] >= self::MSD_GRACE_PERIOD) {
				$msd_list[] = $fqdn;
			}
		}

		if (!is_null($current_account)) {
			self::do_msd_run_int($current_account, $n, $body);
		}

		// Only on Friday.
		if (count($msd_list) > 0) {
			$c->move_to_msd($msd_list);
		}
	}

	public static function update_completed_transfers() {
		// Some may have slipped through at the end of the month.
		$fqdns = self::process_completed_transfers('tran');
		// Normal flow.
		$fqdns += self::process_completed_transfers('tranAdv');
		if (count($fqdns) > 0) {
			echo_list("Transferred", $fqdns);
		}
	}

	/**
	 * Process any domains that have really transferred.
	 */
	private static function process_completed_transfers($type) {
		$c = self::get_instance()->get_console();

		// First we run over any and all completed transfers
		$transferred_fqdns = iterator_to_array($c->list_payment_queue($type));
		if (count($transferred_fqdns) == 0) {
			return array();
		}

		// Eliminate those we know nothing about, and get extended information
		// for those we do.
		$pending_payment = self::get_pending_transfers_subset($transferred_fqdns);
		if (count($pending_payment) == 0) {
			return array();
		}

		// Process the payment.
		$fqdns = array_keys($pending_payment);
		try {
			$c->pay_from_deposit($type, $fqdns);
		} catch (Registry_BillingException $bex) {
			printf("Insufficient funds to complete transfers of type '%s'. Halting.\n", $type);
			return array();
		}

		// If successful, we shift to the next stage: syncing.
		$ids = array();
		foreach ($pending_payment as $r) {
			$ids[] = $r['id'];
		}
		self::update_completion_status($ids, 'syncing');

		return $fqdns;
	}

	/**
	 * Sync the details of any transferred domains and mark them as completed.
	 * This has been coded in such a way that if any part of it fails, it will
	 * fail safely.
	 */
	public static function update_domains_pending_syncing() {
		$c = self::get_instance()->get_console();

		$synced_ids = array();
		foreach (self::get_syncing_domains() as $fqdn => $r) {
			$d = $c->query_domain($fqdn);
			if ($d['billing_status'] == 'autorenew') {
				// We do *not* want this on.
				$c->unset_domain_autorenew($fqdn);
			}
			if ($d['tech'] != $r['account_contact']) {
				$c->update_technical_contact($fqdn, $d['tech'], $r['account_contact']);
			}

			Domains::save_nameservers($r['id'], $d['nameservers']);
			$years = gmdate('Y', $d['expires']) - gmdate('Y', $d['created']);
			Domains::fix_domain_validity($r['id'], $d['created'], $years);

			$synced_ids[] = $r['id'];
		}
		self::update_completion_status($synced_ids, 'completed');
	}

	/**
	 * Checks the status of any transfers that have not yet completed. The
	 * primary purpose behind this is to catch stragglers such as charity
	 * domains, transferred domains set to 'autorenew', and domains that
	 * have lapsed while pending transfer.
	 */
	public static function update_pending_transfers() {
		$c = self::get_instance()->get_console();

		$lapsed = array();
		$charity = array();
		$safe_to_purge = true;
		foreach (self::get_pending_transfers() as $fqdn => $r) {
			try {
				$d = $c->query_domain($fqdn);
				switch ($d['billing_status']) {
				case 'autorenew':
					// We do *not* want this on.
					$c->unset_domain_autorenew($fqdn);
					break;

				case 'notbillable':
				case 'charity':
					$charity[$r['id']] = $fqdn;
					break;
				}
			} catch (Registry_Exception $ex) {
				// XXX Should be checking against the code.
				if ($ex->getMessage() == "Object does not exist [Domain name does not exist]") {
					$lapsed[$r['id']] = $fqdn;
				} elseif ($ex->getMessage() != "Authorization error [Domain is managed by another reseller]") {
					return;
				}
			}
		}

		if (count($charity) > 0) {
			self::update_completion_status(array_keys($charity), 'syncing');
			echo_list('Transferred charity domains', $charity);
		}
		if (count($lapsed) > 0) {
			self::update_completion_status(
				array_keys($lapsed),
				'failed',
				'Transfer failed; domain is no longer registered');
			echo_list('Lapsed domains', $lapsed);
		}

		$to_purge = self::get_overdue_transfers();
		if (count($to_purge) > 0) {
			self::update_completion_status(
				$to_purge, 'failed', 'Transfer overdue; purged');
			echo_list('Overdue', array_keys($to_purge));
		}
	}

	// }}}
}

// Initialise the plugin.
if (STATUS == 'LIVE' || STATUS == 'STAGING') {
	IEDRPlugin::get_instance();
}
